package checkers

import (
	"bytes"
	"strconv"
	"strings"
)

// renderBoard renders a static ASCII board (used for finished games).
func renderBoard(board [BoardSize][BoardSize]*Piece) string {
	var buf bytes.Buffer
	buf.WriteString("\n```\n")
	buf.WriteString("    a   b   c   d   e   f   g   h\n")
	buf.WriteString("  +---+---+---+---+---+---+---+---+\n")
	for r := 0; r < BoardSize; r++ {
		buf.WriteString(strconv.Itoa(r) + " |")
		for c := 0; c < BoardSize; c++ {
			if (r+c)%2 == 0 {
				buf.WriteString("   |")
				continue
			}
			p := board[r][c]
			if p == nil {
				buf.WriteString(" Â· |")
				continue
			}
			if p.Color == RED {
				if p.King {
					buf.WriteString(" â™” |")
				} else {
					buf.WriteString(" â— |")
				}
			} else {
				if p.King {
					buf.WriteString(" â™š |")
				} else {
					buf.WriteString(" â—‹ |")
				}
			}
		}
		buf.WriteString("\n  +---+---+---+---+---+---+---+---+\n")
	}
	buf.WriteString("```\n")
	return buf.String()
}

func renderInteractiveBoard(board [BoardSize][BoardSize]*Piece, gameID string, selectedRow, selectedCol int, callerAddr string, currentTurn Color, g *Game) string {
	var buf bytes.Buffer

	// Board with better styling
	buf.WriteString("|     | a | b | c | d | e | f | g | h |     |\n")
	buf.WriteString("|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:---:|\n")

	for r := 0; r < BoardSize; r++ {
		buf.WriteString("| **" + strconv.Itoa(r) + "** |")
		for c := 0; c < BoardSize; c++ {
			isSelected := r == selectedRow && c == selectedCol

			if (r+c)%2 == 0 {
				// Light square (non-playable)
				buf.WriteString("   |")
				continue
			}

			p := board[r][c]
			if p == nil {
				// Empty dark square
				if selectedRow >= 0 && selectedCol >= 0 {
					// Make it a move destination link - highlight possible moves
					link := "checkers$help&func=Move&.send=&gameID=" + gameID + "&fromRow=" + strconv.Itoa(selectedRow) + "&fromCol=" + strconv.Itoa(selectedCol) + "&toRow=" + strconv.Itoa(r) + "&toCol=" + strconv.Itoa(c)
					buf.WriteString(" [Â·](" + link + ") |")
				} else {
					buf.WriteString(" Â· |")
				}
			} else {
				// Piece on square
				var pieceSymbol string
				if p.Color == RED {
					if p.King {
						pieceSymbol = "â™”"
					} else {
						pieceSymbol = "ğŸ”´"
					}
				} else {
					if p.King {
						pieceSymbol = "â™š"
					} else {
						pieceSymbol = "âš«"
					}
				}

				// Highlight selected piece
				if isSelected {
					pieceSymbol = "âœ¦"
				}

				canSelect := p.Color == currentTurn

				if canSelect && !isSelected {
					link := "?game=" + gameID + "&select=" + strconv.Itoa(r) + "," + strconv.Itoa(c)
					buf.WriteString(" [" + pieceSymbol + "](" + link + ") |")
				} else {
					buf.WriteString(" " + pieceSymbol + " |")
				}
			}
		}
		buf.WriteString(" **" + strconv.Itoa(r) + "** |\n")
	}

	buf.WriteString("|     | a | b | c | d | e | f | g | h |     |\n")

	return buf.String()
}

func renderGame(g *Game, queryParams map[string]string, callerAddr string) string {
	var output strings.Builder

	// Header with game ID
	output.WriteString("# ğŸ® Game: `" + g.ID + "`\n\n")

	// Navigation bar
	output.WriteString("> [ğŸ  Home](?) â€¢ [ğŸ“‹ All Games](?list)")
	if callerAddr != "" {
		output.WriteString(" â€¢ [ğŸ‘¤ My Games](?mygames)")
	}
	output.WriteString("\n\n")

	// Game status box
	output.WriteString("---\n\n")

	if g.Status == StatusActive {
		turnEmoji := "ğŸ”´"
		turnText := "RED"
		if g.Turn == BLACK {
			turnEmoji = "âš«"
			turnText = "BLACK"
		}
		output.WriteString("### " + turnEmoji + " " + turnText + "'s Turn")
		if isPlayerTurn(g, callerAddr) {
			output.WriteString(" â€” *It's your move!*")
		}
		output.WriteString("\n\n")
	} else {
		// Game over
		var statusEmoji string
		switch g.Status {
		case StatusRedWon:
			statusEmoji = "ğŸ† RED WINS!"
		case StatusBlackWon:
			statusEmoji = "ğŸ† BLACK WINS!"
		case StatusDraw:
			statusEmoji = "ğŸ¤ DRAW"
		}
		output.WriteString("### " + statusEmoji + "\n\n")
	}

	// Players info
	output.WriteString("| Player | Address |\n")
	output.WriteString("|:------:|:--------|\n")
	redIndicator := "ğŸ”´"
	blackIndicator := "âš«"
	if g.Turn == RED && g.Status == StatusActive {
		redIndicator = "â–¶ï¸ ğŸ”´"
	} else if g.Turn == BLACK && g.Status == StatusActive {
		blackIndicator = "â–¶ï¸ âš«"
	}
	output.WriteString("| " + redIndicator + " RED | `" + g.Red + "` |\n")
	output.WriteString("| " + blackIndicator + " BLACK | `" + g.Black + "` |\n\n")

	// Parse query params for selection
	selectedRow, selectedCol := -1, -1
	if selectParam := queryParams["select"]; selectParam != "" {
		coords := strings.Split(selectParam, ",")
		if len(coords) == 2 {
			selectedRow, _ = strconv.Atoi(coords[0])
			selectedCol, _ = strconv.Atoi(coords[1])
		}
	}

	output.WriteString("---\n\n")

	// Board section
	output.WriteString("### ğŸ“‹ Board\n\n")

	if g.Status == StatusActive {
		output.WriteString(renderInteractiveBoard(g.Board, g.ID, selectedRow, selectedCol, callerAddr, g.Turn, g))

		// Legend
		output.WriteString("\n**Legend:** ğŸ”´ Red â€¢ âš« Black â€¢ â™” Red King â€¢ â™š Black King â€¢ Â· Empty\n\n")

		if selectedRow >= 0 && selectedCol >= 0 {
			col := string(rune('a' + selectedCol))
			output.WriteString("> âœ¦ **Selected:** `" + col + strconv.Itoa(selectedRow) + "` â€” Click a â—Œ to move there\n\n")
			output.WriteString("[âŒ Clear Selection](?game=" + g.ID + ")\n\n")
		} else {
			output.WriteString("> ğŸ’¡ **Tip:** Click one of your pieces to select it, then click where to move\n\n")
		}
	} else {
		output.WriteString(renderBoard(g.Board))
	}

	// Move history
	output.WriteString("---\n\n")
	output.WriteString("### ğŸ“œ Move History\n\n")

	if len(g.History) > 0 {
		output.WriteString("| # | From | To | Player | Capture |\n")
		output.WriteString("|:-:|:----:|:--:|:------:|:-------:|\n")
		for i, move := range g.History {
			from := string(rune('a'+move.From.Col)) + strconv.Itoa(move.From.Row)
			to := string(rune('a'+move.To.Col)) + strconv.Itoa(move.To.Row)

			playerEmoji := "ğŸ”´"
			if move.Player == BLACK {
				playerEmoji = "âš«"
			}

			captureText := "â€”"
			if len(move.Captured) > 0 {
				captureText = "ğŸ’¥ " + strconv.Itoa(len(move.Captured))
			}

			if move.KingPromoted {
				to += " ğŸ‘‘"
			}

			output.WriteString("| " + strconv.Itoa(i+1) + " | " + from + " | " + to + " | " + playerEmoji + " | " + captureText + " |\n")
		}
	} else {
		output.WriteString("*No moves yet â€” make the first move!*\n")
	}

	return output.String()
}

func renderList() string {
	if len(games) == 0 {
		return "*No games yet. Be the first to create one!*\n"
	}

	var buf strings.Builder
	buf.WriteString("| Game | Status | ğŸ”´ Red | âš« Black |\n")
	buf.WriteString("|:-----|:------:|:-------|:--------|\n")

	for id, g := range games {
		redShort := g.Red
		blackShort := g.Black
		if len(redShort) > 10 {
			redShort = redShort[:10] + "â€¦"
		}
		if len(blackShort) > 10 {
			blackShort = blackShort[:10] + "â€¦"
		}

		statusEmoji := "ğŸ®"
		switch g.Status {
		case StatusRedWon:
			statusEmoji = "ğŸ”´ğŸ†"
		case StatusBlackWon:
			statusEmoji = "âš«ğŸ†"
		case StatusDraw:
			statusEmoji = "ğŸ¤"
		}

		buf.WriteString("| [" + id + "](?game=" + id + ") | " + statusEmoji + " | `" + redShort + "` | `" + blackShort + "` |\n")
	}
	return buf.String()
}

func renderMyGames(callerAddr string) string {
	if callerAddr == "" {
		return "### ğŸ‘¤ My Games\n\n*Connect wallet to see your games*\n"
	}

	myGames := GamesByAddress(callerAddr)
	if len(myGames) == 0 {
		return "### ğŸ‘¤ My Games\n\n*No games yet â€” create one to get started!*\n"
	}

	var buf strings.Builder
	buf.WriteString("### ğŸ‘¤ My Games\n\n")
	buf.WriteString("| Game | Status | You | Opponent |\n")
	buf.WriteString("|:-----|:------:|:---:|:---------|\n")

	for _, id := range myGames {
		g, ok := games[id]
		if !ok {
			continue
		}

		var myColor string
		var opponent string
		if g.Red == callerAddr {
			myColor = "ğŸ”´"
			opponent = g.Black
		} else {
			myColor = "âš«"
			opponent = g.Red
		}

		opponentShort := opponent
		if len(opponentShort) > 10 {
			opponentShort = opponentShort[:10] + "â€¦"
		}

		statusEmoji := "ğŸ®"
		if g.Status != StatusActive {
			if (g.Winner == RED && g.Red == callerAddr) || (g.Winner == BLACK && g.Black == callerAddr) {
				statusEmoji = "ğŸ†"
			} else if g.Status == StatusDraw {
				statusEmoji = "ğŸ¤"
			} else {
				statusEmoji = "ğŸ’€"
			}
		} else if isPlayerTurn(g, callerAddr) {
			statusEmoji = "â³"
		}

		buf.WriteString("| [" + id + "](?game=" + id + ") | " + statusEmoji + " | " + myColor + " | `" + opponentShort + "` |\n")
	}

	return buf.String()
}

func renderHome(callerAddr string) string {
	var output strings.Builder

	// Hero section
	output.WriteString("# â™Ÿï¸ Gno Checkers\n\n")
	output.WriteString("> A fully on-chain 1v1 Checkers game built on Gno\n\n")

	output.WriteString("---\n\n")

	// Quick actions
	output.WriteString("## ğŸ® Play Now\n\n")
	output.WriteString("[**â• Create New Game**](checkers$help&func=CreateGame)\n\n")

	// How it works
	output.WriteString("### How to Play\n\n")
	output.WriteString("| Step | Action |\n")
	output.WriteString("|:----:|:-------|\n")
	output.WriteString("| 1ï¸âƒ£ | Create a game with opponent's address |\n")
	output.WriteString("| 2ï¸âƒ£ | ğŸ”´ RED moves first, then âš« BLACK |\n")
	output.WriteString("| 3ï¸âƒ£ | Click your piece, then click destination |\n")
	output.WriteString("| 4ï¸âƒ£ | Capture all enemy pieces to win! |\n\n")

	// Rules summary
	output.WriteString("### Rules\n\n")
	output.WriteString("- Pieces move **diagonally forward**\n")
	output.WriteString("- **Jump** over enemies to capture them\n")
	output.WriteString("- Reach the end to become a **King** ğŸ‘‘\n")
	output.WriteString("- Kings move in **all diagonal directions**\n")
	output.WriteString("- **Captures are mandatory** when available\n\n")

	output.WriteString("---\n\n")

	// Navigation
	output.WriteString("## ğŸ“‹ Games\n\n")
	output.WriteString("[View All Games](?list)")
	if callerAddr != "" {
		output.WriteString(" â€¢ [My Games](?mygames)")
	}
	output.WriteString("\n\n")

	// Show user's games if logged in
	if callerAddr != "" {
		output.WriteString(renderMyGames(callerAddr))
		output.WriteString("\n")
	}

	// List all games
	output.WriteString("### ğŸŒ All Games\n\n")
	output.WriteString(renderList())

	return output.String()
}
